<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>UltraRAG Blog</title>
        <link>https://ultrarag.github.io/website/blog</link>
        <description>UltraRAG Blog</description>
        <lastBuildDate>Fri, 23 Jan 2026 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[UltraRAG 3.0: No More Black Boxes, Full Transparency in Reasoning]]></title>
            <link>https://ultrarag.github.io/website/blog/ultrarag-3.0-release</link>
            <guid>https://ultrarag.github.io/website/blog/ultrarag-3.0-release</guid>
            <pubDate>Fri, 23 Jan 2026 00:00:00 GMT</pubDate>
            <description><![CDATA["Validating an algorithm prototype takes a week, but building a usable system takes months." This seemingly sarcastic quip is the real predicament every algorithm engineer must face.]]></description>
            <content:encoded><![CDATA[<p><strong>"Validating an algorithm prototype takes a week, but building a usable system takes months."</strong> This seemingly sarcastic quip is the real predicament every algorithm engineer must face.</p><p>Today, Tsinghua University's THUNLP Lab, Northeastern University's NEUIR Lab, OpenBMB, ModelBest and AI9Stars jointly release <strong>UltraRAG 3.0</strong>, addressing these pain points with a developer-centric technical framework featuring 3 core advantages:</p><ul>
<li class="">
<p><strong>One-click leap from logic to prototype, letting algorithm engineers focus on "algorithms"</strong>: Provides a "what you see is what you get" Pipeline builder that automatically handles tedious interface encapsulation. Just focus on logic orchestration, and static code instantly becomes an interactive demo system.</p>
</li>
<li class="">
<p><strong>Full-chain white-box transparency, "pixel-level" visualization of reasoning traces</strong>: Creates a "transparent" reasoning verification window, presenting in real-time every loop, branch, and decision detail of the model during complex long-chain tasks.</p>
</li>
<li class="">
<p><strong>Built-in intelligent development assistant, your "interactive development guide"</strong>: Embeds an AI assistant that understands the framework, assisting in generating Pipeline configurations and optimizing Prompts through natural language interaction, greatly lowering the barrier to entry.</p>
</li>
</ul>
<!-- -->
<video controls="" preload="metadata" class="blogVideo"><source src="/website/assets/medias/01-4277857a315d1d5194183a5a3dd33a74.mp4" type="video/mp4"></video>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="logic-as-application--a-zero-distance-experience-from-orchestration-to-interaction">Logic as Application â€” A "Zero-Distance" Experience from Orchestration to Interaction<a href="https://ultrarag.github.io/website/blog/ultrarag-3.0-release#logic-as-application--a-zero-distance-experience-from-orchestration-to-interaction" class="hash-link" aria-label="Direct link to Logic as Application â€” A &quot;Zero-Distance&quot; Experience from Orchestration to Interaction" title="Direct link to Logic as Application â€” A &quot;Zero-Distance&quot; Experience from Orchestration to Interaction" translate="no">â€‹</a></h2><p>Let the endpoint of algorithms no longer be cold console logs. UltraRAG 3.0 automatically handles tedious interface encapsulation and parameter integration, ensuring that the moment logic orchestration is complete, an interactive demo interface is simultaneously generated:</p><ul>
<li class=""><strong>Configuration as Application</strong>: Simply define the Pipeline's YAML configuration file, and the framework automatically parses and transforms it into a standard interactive Demo.</li>
<li class=""><strong>Dual-Mode Builder</strong>: To balance ease of use and flexibility, we've built a construction engine with real-time synchronization between visual and code modes:<!-- -->
<ul>
<li class="">Canvas Mode: Intuitively assemble complex logic like Loop and Branch through UI components, like building blocks.</li>
<li class="">Code Mode: Directly edit YAML configuration files with the canvas view rendering updates in real-time, meeting developers' needs for precise parameter fine-tuning.</li>
</ul>
</li>
<li class=""><strong>One-Click Build &amp; Verify</strong>: After construction, click the "Build" button at the top. The system automatically performs logic self-checks and syntax validation, dynamically generating parameter configuration panels. The instant parameters are ready, static algorithm logic instantly transforms into an interactive system, truly achieving "what you write is what you get, what you get is what you use."</li>
</ul>
<!-- -->
<video controls="" preload="metadata" class="blogVideo"><source src="/website/assets/medias/02-395059a03e0bbfb22a8be5260106f60d.mp4" type="video/mp4"></video>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="reject-black-boxes--making-complex-rag-reasoning-traces-clearly-visible">Reject "Black Boxes" â€” Making Complex RAG Reasoning Traces Clearly Visible<a href="https://ultrarag.github.io/website/blog/ultrarag-3.0-release#reject-black-boxes--making-complex-rag-reasoning-traces-clearly-visible" class="hash-link" aria-label="Direct link to Reject &quot;Black Boxes&quot; â€” Making Complex RAG Reasoning Traces Clearly Visible" title="Direct link to Reject &quot;Black Boxes&quot; â€” Making Complex RAG Reasoning Traces Clearly Visible" translate="no">â€‹</a></h2><p>As RAG technology evolves from simple single-round retrieval to multi-round dynamic decision-making, reasoning chains often extend to hundreds of Steps. Without intermediate state monitoring, the debugging process is like starting over in the fog, with error localization relying entirely on "guessing."</p><p>UltraRAG 3.0 redefines the <strong>Chat interface</strong> â€” it's not just the user interaction entry point, but also a <strong>logic verification window</strong>. We deeply understand that for developers, knowing "what the result is" is far from enough; seeing "how the result came about" is the key to optimization.</p><p>Through the "Show Thinking" panel, we provide pixel-level real-time visualization of the system's entire "thinking" process â€” from complex loop branches to specific tool calls, <strong>all intermediate states are presented in a structured streaming format</strong>. Even for complex long-process tasks like DeepResearch, developers can track execution progress in real-time, making the process no longer a dark wait. When Bad Cases appear, developers no longer need to dig through backend logs; they can directly compare retrieval slices with final answers on the interface, quickly determining whether the problem lies in "data layer noise" or "model layer hallucination," greatly shortening the optimization iteration cycle.</p><p>Here we selected two typical scenarios from the AgentCPM-Report workflow to demonstrate the practical effects of "white-box" debugging:</p>
<!-- -->
<video controls="" preload="metadata" class="blogVideo"><source src="/website/assets/medias/03-536d5b2a9c1219c8f6f870e4484dce76.mp4" type="video/mp4"></video>
<video controls="" preload="metadata" class="blogVideo"><source src="/website/assets/medias/04-dc94838f34b06de99d74e57a32456f96.mp4" type="video/mp4"></video>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="breaking-free-from-framework-shackles-in-custom-development">Breaking Free from "Framework Shackles" in Custom Development<a href="https://ultrarag.github.io/website/blog/ultrarag-3.0-release#breaking-free-from-framework-shackles-in-custom-development" class="hash-link" aria-label="Direct link to Breaking Free from &quot;Framework Shackles&quot; in Custom Development" title="Direct link to Breaking Free from &quot;Framework Shackles&quot; in Custom Development" translate="no">â€‹</a></h2><p>Wanting to try a new algorithm logic often requires diving deep into the framework's internals and rewriting large amounts of inherited classes. To achieve <strong>10%</strong> core algorithm innovation, one has to bear <strong>90%</strong> of framework learning costs.</p><p><strong>UltraRAG 3.0 embeds the entire development documentation and best practices into the framework's built-in intelligent assistant</strong>. While it may not help you write an entire project like Cursor, it is absolutely the most efficient assistive tool that understands UltraRAG. Through natural language interaction, it helps you completely bridge the cognitive gap between "reading documentation" and "writing configurations":</p><ul>
<li class=""><strong>Configuration Generation</strong>: Just describe your requirements (e.g., "I want a pipeline with multi-way recall and reranking"), and the assistant automatically generates a standard Pipeline structure draft that can be used directly with minor adjustments.</li>
<li class=""><strong>Prompt Tuning</strong>: The assistant provides targeted Prompt optimization suggestions based on the current task context, quickly adapting to specific business scenarios.</li>
<li class=""><strong>Understanding Assistance</strong>: Can't understand a parameter or logic? No need to open a browser and browse through documentation. Just ask and get development suggestions and code examples, keeping the coding process uninterrupted.</li>
</ul><h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="practical-demo-what-it-can-do-for-you">Practical Demo: What It Can Do For You<a href="https://ultrarag.github.io/website/blog/ultrarag-3.0-release#practical-demo-what-it-can-do-for-you" class="hash-link" aria-label="Direct link to Practical Demo: What It Can Do For You" title="Direct link to Practical Demo: What It Can Do For You" translate="no">â€‹</a></h3><p>We demonstrate four real interaction scenarios here, showing how it transforms natural language into "executable logic":</p><p><strong>1. Structural Adjustment: Modify Pipeline with One Sentence</strong></p><blockquote>
<p>User: "Please help me modify the current Pipeline to add a Citation module for fact-checking the generated content."</p>
</blockquote><p><strong>2. Scenario Adaptation: Targeted Prompt Optimization</strong></p><blockquote>
<p>User: "I need to optimize the current Prompt for the legal domain. Please adjust the prompt so that the generated answers are more professional and accurate in terms of terminology and logical reasoning in this field."</p>
</blockquote><p><strong>3. Configuration Adjustment: Easily Modify Underlying Parameters</strong></p><blockquote>
<p>User: "I want to switch the generation backend configuration. Please change the generation model backend to OpenAI, change the model name to qwen3-32b, and the API service is deployed on port 65503."</p>
</blockquote><p><strong>4. Free Tuning: Shortcut from Concept to Implementation</strong></p><blockquote>
<p>User: "I want to reference this paper: <a href="https://arxiv.org/pdf/2410.08821" target="_blank" rel="noopener noreferrer" class="">https://arxiv.org/pdf/2410.08821</a> (DeepNote), to redesign my RAG pipeline. Please analyze the core ideas in the article and help me build a similar Pipeline architecture."</p>
</blockquote>
<!-- -->
<video controls="" preload="metadata" class="blogVideo"><source src="/website/assets/medias/05-dd008f5e1f5989a453979dcf82708d0d.mp4" type="video/mp4"></video>]]></content:encoded>
            <category>release</category>
            <category>ultrarag</category>
        </item>
        <item>
            <title><![CDATA[UltraRAG 2.1: Deep Knowledge Integration, Cross-Modal Support]]></title>
            <link>https://ultrarag.github.io/website/blog/ultrarag-2.1-release</link>
            <guid>https://ultrarag.github.io/website/blog/ultrarag-2.1-release</guid>
            <pubDate>Tue, 11 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[In the process of building knowledge bases, setting up experimental systems, and evaluating results, researchers always encounter similar challenges: How to achieve multimodal retrieval and generation within a unified framework? How to efficiently integrate multi-source knowledge? And how to make complex RAG experiments easier to build and reproduce?]]></description>
            <content:encoded><![CDATA[<p>In the process of building knowledge bases, setting up experimental systems, and evaluating results, researchers always encounter similar challenges: How to achieve multimodal retrieval and generation within a unified framework? How to efficiently integrate multi-source knowledge? And how to make complex RAG experiments easier to build and reproduce?</p><p><strong>UltraRAG 2.1</strong> addresses these research challenges with comprehensive upgrades focused on practical needs. This update brings core enhancements in three directions: <strong>native multimodal support, automated knowledge integration and corpus construction, and unified build-and-evaluate RAG workflows</strong>:</p><ul>
<li class=""><strong>Native Multimodal Support</strong>: Unified Retriever, Generation, and Evaluation modules with full multimodal retrieval and generation support; new <strong>VisRAG Pipeline</strong> enabling a complete closed-loop from local PDF indexing to multimodal retrieval and generation.</li>
<li class=""><strong>Automated Knowledge Integration &amp; Corpus Construction</strong>: Supports multi-format document parsing and chunked indexing, seamlessly integrating MinerU for easy construction of personalized knowledge bases.</li>
<li class=""><strong>Unified Build &amp; Evaluate RAG Workflows</strong>: Compatible with multiple retrieval and generation inference engines, providing a standardized evaluation system with full-chain visual analysis, achieving a unified process from model invocation to result verification.</li>
</ul><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="native-multimodal-support">Native Multimodal Support<a href="https://ultrarag.github.io/website/blog/ultrarag-2.1-release#native-multimodal-support" class="hash-link" aria-label="Direct link to Native Multimodal Support" title="Direct link to Native Multimodal Support" translate="no">â€‹</a></h2><p>Previously, multimodal RAG often relied on multiple independent tools: text tasks and visual tasks belonged to different workflows, requiring researchers to switch between feature extraction, retrieval, generation, and evaluation tools, with inconsistent interfaces and difficult reproducibility.</p><p><strong>UltraRAG 2.1</strong> systematically integrates the multimodal RAG pipeline. All core Servers â€” <strong>Retriever, Generation, and Evaluation</strong> â€” now natively support multimodal tasks and can flexibly connect to various visual, text, or cross-modal models. Researchers can freely orchestrate their own multimodal pipelines within the unified framework â€” whether for document QA, image-text retrieval, or cross-modal generation â€” all achievable with minimal effort for end-to-end integration. Additionally, the framework's built-in <strong>Benchmarks</strong> cover various tasks including visual QA, with a unified evaluation system for researchers to quickly conduct and compare multimodal experiments.</p><p>Building on this, <strong>UltraRAG 2.1 introduces the VisRAG Pipeline</strong>, enabling a complete closed-loop from local PDF indexing to multimodal retrieval and generation. This feature is based on the research in "VisRAG: Vision-based Retrieval-augmented Generation on Multi-modality Documents," which proposes a vision-enhanced retrieval-augmented generation framework for multimodal documents. By jointly modeling document image information (such as charts, formulas, layout structures) with text content, it significantly improves content understanding and QA capabilities for complex scientific documents. UltraRAG integrates this approach, enabling researchers to reproduce VisRAG experiments directly on real PDF document scenarios and further extend multimodal retrieval-generation research and applications.</p><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="automated-knowledge-integration--corpus-construction">Automated Knowledge Integration &amp; Corpus Construction<a href="https://ultrarag.github.io/website/blog/ultrarag-2.1-release#automated-knowledge-integration--corpus-construction" class="hash-link" aria-label="Direct link to Automated Knowledge Integration &amp; Corpus Construction" title="Direct link to Automated Knowledge Integration &amp; Corpus Construction" translate="no">â€‹</a></h2><p>During RAG development, developers need to repeatedly parse, clean, and chunk materials from different sources. As a result, the RAG construction process is often slowed by trivial engineering details, compressing the space for research innovation.</p><p><strong>UltraRAG 2.1's</strong> <strong>Corpus Server</strong> makes all of this simple. Users can import corpora from different sources in one go without writing complex scripts â€” whether Word documents, e-books, or web archives â€” all automatically parsed into a unified text format. For PDF parsing, UltraRAG seamlessly integrates <strong>MinerU</strong>, accurately recognizing complex layouts and multi-column structures for high-fidelity text restoration. For mixed image-text files, it also supports converting PDFs page-by-page to images, making visual layouts part of the knowledge. For chunking strategies, <strong>Corpus Server</strong> offers multi-granularity options: supporting token-level, sentence-level, and custom rules, enabling fine-grained control of semantic boundaries while naturally adapting to structured text like Markdown.</p>
<!-- -->
<p><img decoding="async" loading="lazy" alt="UltraRAG 2.1 å›¾ç¤º 1" src="https://ultrarag.github.io/website/assets/images/1-3e19c1f17e8d186267edcb7ca36225f6.jpg" width="1280" height="657" class="img_ev3q"></p>
<p>Through this automated pipeline, Corpus Server modularizes the corpus import, parsing, and chunking process, reducing manual scripting and format adaptation work, enabling knowledge base construction to be directly integrated into the standardized RAG pipeline workflow.</p><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="unified-build--evaluate-rag-workflows">Unified Build &amp; Evaluate RAG Workflows<a href="https://ultrarag.github.io/website/blog/ultrarag-2.1-release#unified-build--evaluate-rag-workflows" class="hash-link" aria-label="Direct link to Unified Build &amp; Evaluate RAG Workflows" title="Direct link to Unified Build &amp; Evaluate RAG Workflows" translate="no">â€‹</a></h2><blockquote>
<p>"Chunking, indexing, retrieval, generation, evaluation â€” each step requires different scripts, too cumbersome!"
"Every time I change a parameter or switch a model, do I need to rebuild the entire pipeline?"
"After the experiment finally runs, how do I keep evaluation results consistent and comparable?"</p>
</blockquote><p>These questions are frustrations that almost every RAG researcher has experienced. Existing frameworks often provide fragmented and incompatible support for retrieval, model integration, and evaluation, forcing researchers to repeatedly switch between different tools, with every modification potentially triggering a rebuild of the entire experimental chain. UltraRAG 2.1's goal is to make complex workflows clear and unified again.</p><p>At the retrieval level, the framework supports sparse, dense, hybrid, and multimodal retrieval, compatible with multiple backend engines including Infinity, Sentence-Transformers, and OpenAI. Researchers can freely combine retrieval strategies and models for flexible pipeline design. For model generation, UltraRAG 2.1 simultaneously supports vLLM offline inference and Hugging Face local debugging, while maintaining full compatibility with the OpenAI interface, making model switching and deployment require no code changes. For evaluation, UltraRAG builds a unified Evaluation Server that can compute metrics like ACC and ROUGE for generated results, and supports TREC evaluation and significance analysis for retrieval results. Combined with the visual Case Study UI, researchers can intuitively compare the performance of different models and strategies, making "debugging" truly become "understanding."</p><p>Furthermore, UltraRAG achieves full-chain integration from data import to retrieval, generation, and evaluation through a YAML configuration-driven workflow mechanism. Researchers only need to write minimal configuration files to quickly define and reproduce experimental workflows.</p>
<!-- -->
<p><img decoding="async" loading="lazy" alt="UltraRAG 2.1 å›¾ç¤º 2" src="https://ultrarag.github.io/website/assets/images/2-2c3fd8026c9eef51e9ec81ceb3ede664.jpg" width="1280" height="791" class="img_ev3q"></p>]]></content:encoded>
            <category>release</category>
            <category>ultrarag</category>
        </item>
        <item>
            <title><![CDATA[UltraRAG 2.0: Minimal Code, Maximum Innovation]]></title>
            <link>https://ultrarag.github.io/website/blog/ultrarag-2.0-release</link>
            <guid>https://ultrarag.github.io/website/blog/ultrarag-2.0-release</guid>
            <pubDate>Thu, 28 Aug 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[Retrieval-Augmented Generation (RAG) systems are evolving from the early simple "retrieval + generation" concatenation toward complex knowledge systems integrating adaptive knowledge organization, multi-round reasoning, and dynamic retrieval (typical examples include DeepResearch and Search-o1). However, this increase in complexity creates high engineering implementation costs for developers when reproducing methods and rapidly iterating on new ideas.]]></description>
            <content:encoded><![CDATA[<p>Retrieval-Augmented Generation (RAG) systems are evolving from the early simple "retrieval + generation" concatenation toward complex knowledge systems integrating adaptive knowledge organization, multi-round reasoning, and dynamic retrieval (typical examples include DeepResearch and Search-o1). However, this increase in complexity creates high engineering implementation costs for developers when reproducing methods and rapidly iterating on new ideas.</p><p>To address this pain point, Tsinghua University's THUNLP Lab, Northeastern University's NEUIR Lab, OpenBMB, and AI9Stars jointly launch UltraRAG 2.0 (UR-2.0) â€” <strong>the first RAG framework designed with Model Context Protocol (MCP) architecture</strong>. This design allows researchers to declare complex logic such as serial execution, loops, and conditional branches directly by writing YAML files, enabling rapid implementation of multi-stage reasoning systems with minimal code.</p><p>UltraRAG 2.0 highlights at a glance:</p><ul>
<li class="">
<p>ðŸ§© Component-based Encapsulation: Encapsulates core RAG components as standardized independent MCP Servers;</p>
</li>
<li class="">
<p>ðŸ”Œ Flexible Invocation &amp; Extension: Provides function-level Tool interfaces supporting flexible invocation and extension of capabilities;</p>
</li>
<li class="">
<p>ðŸª„ Lightweight Pipeline Orchestration: Leverages MCP Client to establish streamlined top-down pipeline construction; Compared to traditional frameworks, UltraRAG 2.0 significantly lowers the technical threshold and learning cost of complex RAG systems, allowing researchers to invest more energy in experimental design and algorithm innovation rather than getting bogged down in lengthy engineering implementation.</p>
</li>
</ul><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="simplifying-complexity--only-5-code-for-low-barrier-reproduction">Simplifying Complexity â€” Only 5% Code for Low-Barrier Reproduction<a href="https://ultrarag.github.io/website/blog/ultrarag-2.0-release#simplifying-complexity--only-5-code-for-low-barrier-reproduction" class="hash-link" aria-label="Direct link to Simplifying Complexity â€” Only 5% Code for Low-Barrier Reproduction" title="Direct link to Simplifying Complexity â€” Only 5% Code for Low-Barrier Reproduction" translate="no">â€‹</a></h2><p>The value of "simplicity" is particularly intuitive in practice. Taking IRCoT (<a href="https://arxiv.org/abs/2212.10509" target="_blank" rel="noopener noreferrer" class="">https://arxiv.org/abs/2212.10509</a>), a classic method, as an example â€” it relies on CoT generated by the model for multi-round retrieval until producing the final answer, making the overall process quite complex.</p><p>In the official implementation, the Pipeline portion alone requires nearly 900 lines of handwritten logic; even using other RAG frameworks still requires over 110 lines of code. In contrast, UltraRAG 2.0 achieves equivalent functionality with only about 50 lines of code. More notably, approximately half of that is YAML pseudo-code for orchestration, dramatically lowering the development threshold and implementation cost.</p><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="simple-yet-extraordinary--dozens-of-lines-of-code-for-high-performance-rag-systems">Simple Yet Extraordinary â€” Dozens of Lines of Code for High-Performance RAG Systems<a href="https://ultrarag.github.io/website/blog/ultrarag-2.0-release#simple-yet-extraordinary--dozens-of-lines-of-code-for-high-performance-rag-systems" class="hash-link" aria-label="Direct link to Simple Yet Extraordinary â€” Dozens of Lines of Code for High-Performance RAG Systems" title="Direct link to Simple Yet Extraordinary â€” Dozens of Lines of Code for High-Performance RAG Systems" translate="no">â€‹</a></h2><p>For UltraRAG 2.0, "simplicity" does not mean limited functionality. Leveraging the MCP architecture and flexible YAML pipeline definitions, UltraRAG 2.0 provides researchers with a high-performance, extensible experimental platform. <strong>Researchers can build multi-stage reasoning systems similar to DeepResearch in a very short time</strong>, supporting advanced capabilities like <strong>dynamic retrieval, conditional judgment, and multi-round interaction</strong>.</p><p>In the example, we concatenate <strong>Retriever, Generation, Router</strong> and other modules through YAML to build a reasoning pipeline with both loops and conditional branches, implementing key steps like <strong>Plan Generation â†’ Knowledge Organization â†’ Sub-question Generation</strong> â€” all in <strong>under 100 lines of code</strong>.</p>
<!-- -->
<p><img decoding="async" loading="lazy" alt="UltraRAG 2.0 å›¾ç¤º 1" src="https://ultrarag.github.io/website/assets/images/1-be2800780d0d970e0b7aea572e2504a3.jpg" width="1280" height="542" class="img_ev3q"></p>
<p>In terms of performance, this system achieves a <strong>~12% performance improvement</strong> over Vanilla RAG on complex multi-hop questions, fully validating UltraRAG 2.0's potential in rapidly building complex reasoning systems.</p>
<!-- -->
<p><img decoding="async" loading="lazy" alt="UltraRAG 2.0 å›¾ç¤º 2" src="https://ultrarag.github.io/website/assets/images/2-097afbf79912e756f003a34aedb51b35.jpg" width="1280" height="846" class="img_ev3q"></p>
<p>UltraRAG 2.0 makes building complex reasoning systems truly <strong>low-code, high-performance, and production-ready</strong>. Users can not only achieve performance improvements in research tasks but also quickly deploy in industry applications such as intelligent customer service, educational tutoring, and medical QA, delivering more reliable knowledge-enhanced answers.</p><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="mcp-architecture-and-native-pipeline-control">MCP Architecture and Native Pipeline Control<a href="https://ultrarag.github.io/website/blog/ultrarag-2.0-release#mcp-architecture-and-native-pipeline-control" class="hash-link" aria-label="Direct link to MCP Architecture and Native Pipeline Control" title="Direct link to MCP Architecture and Native Pipeline Control" translate="no">â€‹</a></h2><p>Across different RAG systems, core capabilities like retrieval and generation are functionally highly similar, but due to varying developer implementation strategies, modules often lack unified interfaces and are difficult to reuse across projects. Model Context Protocol (MCP), as an open protocol, standardizes the way context is provided for Large Language Models (LLMs) and adopts a Client-Server architecture, enabling Server components developed following this protocol to be seamlessly reused across different systems.</p><p>Inspired by this, UltraRAG 2.0 abstracts and encapsulates core RAG functions such as retrieval, generation, and evaluation as mutually independent MCP Servers based on the MCP architecture, with invocation through standardized function-level Tool interfaces. This design ensures flexibility in module capability extension while allowing new modules to be integrated in a "hot-pluggable" manner without invasive modifications to the overall codebase. In research scenarios, this architecture enables researchers to rapidly adapt to new models or algorithms with minimal code while maintaining the stability and consistency of the overall system.</p>
<!-- -->
<p><img decoding="async" loading="lazy" alt="UltraRAG 2.0 å›¾ç¤º 3" src="https://ultrarag.github.io/website/assets/images/3-8c0351bfc1f9e9f7fb4ef7aca3525ef6.jpg" width="1280" height="302" class="img_ev3q"></p>
<p>The development of complex RAG reasoning frameworks is significantly challenging, <strong>and the reason UltraRAG 2.0 can support complex system construction under low-code conditions lies in its underlying native support for multi-structure Pipeline flow control</strong>. Whether serial, loop, or conditional branch, all control logic can be defined and scheduled at the YAML level, covering various process expression methods required by complex reasoning tasks. During actual execution, reasoning process scheduling is performed by the built-in Client, whose logic is entirely described by external Pipeline YAML scripts written by users, achieving decoupling from the underlying implementation. Developers can invoke instructions like loop and step like programming language keywords, rapidly building multi-stage reasoning pipelines in a declarative manner.</p><p>By deeply integrating MCP architecture with native process control, UltraRAG 2.0 makes building complex RAG systems as natural and efficient as "orchestrating workflows." Additionally, the framework includes <strong>17 mainstream benchmark tasks and multiple high-quality baselines</strong>, combined with a unified evaluation system and knowledge base support, further improving system development efficiency and experimental reproducibility.</p>
]]></content:encoded>
            <category>release</category>
            <category>ultrarag</category>
        </item>
    </channel>
</rss>